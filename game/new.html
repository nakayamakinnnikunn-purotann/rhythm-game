<!DOCTYPE html>
<html lang="ja">
    <head>
            <meta charset="utf-8">
            <meta http-equiv="x-ua-compatible" content="IE=Edge">
            <meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no">
            <title>イーブニング・レイン</title>
            <!-- <link href='https://fonts.googleapis.com/css?family=Shadows+Into+Light|Audiowide|Merienda+One|Henny+Penny' rel='stylesheet' type='text/css'> -->
            <link href='https://fonts.googleapis.com/css?family=Audiowide|Merienda+One' rel='stylesheet' type='text/css'>

            <style media="screen">
                body{
                    -webkit-text-size-adjust: 100%;
                    font-family: Merienda One, cursive, monospace;
                    /*background: rgb(12, 154, 133);*/
                    background: url("./assets/images/background.jpg") center center no-repeat fixed;
                    background-size:cover;
                    background-color: black;
                    color: rgb(208, 218, 213);
                }
                .title{
                    text-align: center;
                }
                #game-field{
                    position: relative;
                    margin: 8px auto;
                }
                canvas{
                    position: absolute;
                }
                #bg{
                    z-index: 1;
                }
                #app{
                    z-index:2;
                }

            </style>
        </head>
    <body>
        <div class="container">
            <h1 class="title">EVENING RAIN</h1>

            <div id="game-field">
                <canvas id="bg"></canvas>
                <canvas id="app"></canvas>
            </div>

            <div class="info">
                <div id="time"></div>
                <button id="pause">pause</button>
                <button id="resetBtn">reset</button>
                <input type="number" id="seek" value="">
                <div class="instruction">
                    オーソドックスな音ゲーです。降ってくるノーツに合わせてキーボード（どのキーでもOK）を押すか、タップします。<br>
                    長いノーツは長押しします。
                </div>
                <ul class="repertory">
                    <li> Music : "Game gadget at midnight" by <a href="http://dova-s.jp/_contents/author/profile089.html">MATSU</a></li>
                </ul>
            </div>


        </div><!-- container -->

        <script src="timerClass.js" charset="utf-8"></script>
        <script>

/*
描画最適化
・ステートを無闇に変更しない
・パスを事前に書いて最後にまとめて
・バックグラウンドと分ける
・バッファを考えてみる（効果的かは未知数だが）
*/
// var game = function(){
// };

//shorthand
var $id = function(id) { return document.getElementById(id); }
var makeSpanArray = function(span, m, n){
    var array = [];
    for (var i = m; i < m+n; i++) {
        array.push(span * i);
    }
    return array;
}
//定数
var SCREEN_WIDTH = 640;
var SCREEN_HEIGHT = Math.round(SCREEN_WIDTH/16 * 9); // 16:9 ex> 640:360
var NOTE_LIST = null;

// 画面描画用パラメータ（定数（ゲーム中に変更することの無い変数）は慣例として大文字）
var GRID_NUM = 14;
var NOTE_WIDTH = (SCREEN_WIDTH / GRID_NUM) * 0.8; // ノーツの幅：画面サイズで変える？
var NOTE_HEIGHT = 6;

var NOTE_POS_SPAN = SCREEN_WIDTH / GRID_NUM;
// var NOTE_POSES = [NOTE_POS_SPAN*3, NOTE_POS_SPAN*4, NOTE_POS_SPAN*5, NOTE_POS_SPAN*6];
var NOTE_POSES = makeSpanArray(NOTE_POS_SPAN, 5, 4);
var NOTE_POSES_LEN = NOTE_POSES.length;

var NOTE_COLOR = "rgb(139, 236, 242)";
var LONG_NOTE_COLOR = "rgb(77, 60, 212)";
// var WATER_COLOR = "#146f9b";
var WATER_COLOR = "#125779";
var EFFECT_COLOR = NOTE_COLOR;
// var EFFECT_COLOR = "rgba(152, 171, 236, 1)";

// var JUDGE_LINE_COLOR ="rgb(9, 112, 126)";
// var JUDGE_LINE_START_X = 0;
// var JUDGE_LINE_END_X = SCREEN_WIDTH - JUDGE_LINE_START_X;
var JUDGE_LINE_Y = SCREEN_HEIGHT * 0.7; //
var NOTE_DEST_Y = JUDGE_LINE_Y - NOTE_HEIGHT * 0.5; // ノーツ最終位置Y
var EFFECT_HEIGHT = JUDGE_LINE_Y * 0.4; // エフェクトの高さ

var RATING_TEXT_POS_X = SCREEN_WIDTH * 0.5;
var RATING_TEXT_POS_Y = SCREEN_HEIGHT * 0.4;
var SCORE_TEXT_FONT_SIZE = 20;
var SCORE_TEXT_POS_X =  SCREEN_WIDTH * 0.9;
var SCORE_TEXT_POS_Y = SCORE_TEXT_FONT_SIZE * 1.1;

// 判定範囲（sec）
var RATING = {
    out: 0.13,
    good: 0.10,
    cool: 0.05,
    great: 0.03
};
// 加点設定
var SCORE = {
    good: 10,
    cool: 50,
    great: 100,
    hold: 10
}

var SOUND_ASSETS = {
    // bgm: "./assets/two_tor_real.mp3",
    bgm: "./assets/Game_gadget_at_midnight.mpav",
    clap:"./assets/clap.mp3",
    conga: "./assets/conga.mp3"
};
var IMAGE_ASSETS = {
    streetLight: "./assets/images/streetLight.png",
    girl: "./assets/images/girl.png",
}

// HTML要素取得
var app = $id('app');
var bgCanvas = $id('bg');
var holderElement = $id('game-field');
var timerNode = $id('time');
function pause(){
    music.pause();
    timer.pause();
    isPlaying = false;
}
$id('pause').addEventListener('click', pause);

$id('seek').onblur = function(){
    timer.setTime(this.value);
    music.currentTime = this.value;
}

var timer = new Timer();

// 情報格納用変数とか
var noteList = []; //譜面情報
var hitEffect = null;
var score = 0;
var chainNum = 0;
var maxChain = 0;
var rateText = null;
var longNote = null; // ロングノート情報
var btnFlg = false; // ボタンが押下状態フラグ
var isPlaying = false; // プレイ中
var autoPlay = false;
// var autoPlay = true;

var bpm = 180; // dummy
var speed = 1.5;

var currentNoteIndex = 0;

// 譜面位置・判定調整用
var calib = 0; // 判定調整用　RATING.good判定より小さいこと
var zerohour = 0; // （音源中での実際の音楽再生開始時間）譜面load時に修正される
var endhour = 0; // ゲーム終了時間：音源ロード時に設定
var wait = 3.0; // 音源再生までの待ち時間
// var wait = zerohour + _wait; //  計算に利用する最終的な待ち時間

// sound preload
var sounds = {} // サウンド管理;
var images = {} // image管理;
var music, se1, se2;
//forEachで回して登録
var _keys = Object.keys(SOUND_ASSETS);
_keys.forEach(function(key){
    var audio = new Audio(SOUND_ASSETS[key]);
    audio.load();
    var counter = 0;
    // event名にかかわらず、コールバックを即時関数にすると必ずじっこうされる？
    // audio.addEventListener('loadeddata', (function(x){

    // }(key));
    audio.addEventListener('loadeddata', function(){
        sounds[key] = audio; //登録
        console.log(Object.keys(sounds).length+" , 全音源:"+Object.keys(SOUND_ASSETS).length);

        if (Object.keys(sounds).length === _keys.length){
            // init();
            // image load
            var _imgkeys = Object.keys(IMAGE_ASSETS);
            _imgkeys.forEach(function(key){
                var img = new Image();
                // console.log(img);
                img.onload = function(){
                    images[key] = img
                    if (Object.keys(images).length === _imgkeys.length){
                        init();
                    }
                }
                img.src = IMAGE_ASSETS[key];
            });
        }
    });

    // canplaythroughイベントはplay()時にも発生するため、ロードがおわったらイベントリスナをremove
    // http://webkatu.com/remove-eventlistener/
    // audio.addEventListener('loadeddata', (function(x){
    //     return function load(){
    //         sounds[x] = audio; //登録
    //         console.log(Object.keys(sounds).length+" , 全音源:"+Object.keys(SOUND_ASSETS).length);
    //         audio.removeEventListener('loadeddata', load);
    //         if (Object.keys(sounds).length === _keys.length) {
    //
    //             init();
    //         }
    //     }
    // })(key));

    audio.addEventListener('error', function(e){
        counter++;
        // console.log(counter);
        if (counter>10){
            throw new Error(e.target.error);
            alert('failed sound loading :(. Try reloading the browser', e);
        }else{
            // audio.src = "./assets/Game_gadget_at_midnight.mp3"; //test用
            audio.load();
        }
    });

    // 読み込み失敗時の対策、あまり良くない
    setTimeout(function(){
        console.log('読み込みチェック');
        // if(Object.keys(sounds).length !== _keys.length){
        if(sounds[key] != audio){
            alert('音声の読み込みに失敗したようです。リロードしてみてください');
        }
    },3000);

}, this);


function init() {
    // ajaxで譜面情報の取得
    var httpObj = new XMLHttpRequest();
    // httpObj.open("get", "./data/midnight-fumen_sorted.json", true);
    httpObj.open("get", "./data/midnight-fumen_rev1.json", true);
    httpObj.onload = function(){
        importData(this.responseText);

        music = sounds.bgm;
        se1 =  sounds.clap;
        se2 =  sounds.conga;
        app.width = bgCanvas.width = SCREEN_WIDTH;
        app.height = bgCanvas.height  = SCREEN_HEIGHT;
        holderElement.style.width = SCREEN_WIDTH +"px";
        holderElement.style.height = SCREEN_HEIGHT +"px";
        noteList = NOTE_LIST.slice();
        noteList.forEach(function(note){
            if(note.length){
                maxChain += 2;
            } else {
                maxChain++;
            }
        });
        if (endhour == 0) endhour = music.duration + wait;

        gameReset();

        if (autoPlay) btnFlg = true;

        // draw once: background
        var bgctx = bgCanvas.getContext('2d');
        bgctx.fillStyle = "rgba(34, 34, 34, 0.6)";
        bgctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
        bgctx.drawImage(images.girl, SCREEN_WIDTH*0.75, 85);
        drawGradRect(bgctx, 0, JUDGE_LINE_Y,  SCREEN_WIDTH, SCREEN_HEIGHT-JUDGE_LINE_Y, [ [0, WATER_COLOR], [1, "rgba(255, 255, 255, 0)"] ]);
        bgctx.drawImage(images.streetLight,0,0,177,474, 60, 100, 132, 358);

        main();
    }
    httpObj.onerror = function(e){
        console.log(e);
    }
    httpObj.send(null);

}

function gameReset(){
    currentNoteIndex = 0;
    music.pause();
    music.currentTime = zerohour; //0以下の場合は0になる？
    rateText = null;
    chainNum = 0;
    score = 0;
    hitEffect = 0;
    timer.reset();
    timer.run();
    // isPlaying = true;
    // console.log(noteList);
    console.log("reset");
}

// main loop
function main() {
    if (isPlaying){
        timer.update();
        timerNode.innerHTML = timer.time();
        calc();
    };
    screenRender();

    setTimeout(main, 1000/60);
}

// 内部処理用
function calc(){
    var i, len;
    var noteTime;

    // if (!isPlaying) return;
    var time = timer.time();

    // 時間が来たら音楽再生開始
    if (time > wait && music.paused) {
        console.log("music start");
        music.play();
    }
    // endhour に達したら
    if (time > endhour && !music.paused) {
        console.log("music end");
        music.volume -= 0.1;
        music.pause();
    }
    if(time > endhour){
        isPlaying = false;
    }

    for (i = currentNoteIndex, len=noteList.length; i < len; i++){
        noteTime = noteList[i];
    // noteList.forEach(function(noteTime){

        // ロングノートだったら
        if (typeof noteTime == 'object') {
            noteTime = noteTime[0];
        }

        // 無入力判定：判定ラインを超え、かつ判定時間を過ぎたらmiss判定、そして次のターゲットへ
        // ロングノート判定中は引っかからないようにする
        if (time > noteTime+wait + RATING.good && !longNote){
            miss();
            // noteList.shift();
            currentNoteIndex++;
        }

        //オートプレイ
        //great範囲内に入ったら即座に反応
        // ロングノート判定中にロングノート情報を消さないようにする
        if (autoPlay && !longNote) {
            if (time > noteTime + wait - RATING.great){
                judge();
                // noteList.shift();
                // currentNoteIndex++;

            }
        }
    }

    // long note 処理
    if (longNote != null) {
        var rTime = longNote - time + calib;

        // ボタンを押している
        if (btnFlg) {
            // 終了時間に達していない
            if (rTime > 0) {
                // console.log('ji');
                hitEffect = 3;
                effect('hold');
            // 規定時間まで押しつづけたら終了
            }else{
                longNote = null;
                effect('great');
            }

        // 途中で離してしまった
        }else{
            longNote = null;
            effect('miss');
            // miss();
        }
    }

}


function screenRender() {
    var ctx = app.getContext('2d');
    var relativeTime = 0; // 再生位置とノーツ出現情報との差、０のとき判定ライン位置になるように
    var corr = bpm * 1.5 * speed; // 補正、ハイスピ
    var deltaY; // 判定ラインまでの距離
    var drawingPointX = 100; // X軸 描画位置
    var drawingPointY; // Y軸 描画位置
    var noteHeight = 0;
    var effectPosX = null; // エフェクトX位置
    var i, len;
    var noteTime = null;

    //画面初期化：背景色で塗りつぶす
    // ctx.fillStyle = "rgba(0, 0, 0, 0.5)"; // ブラーエフェクト
    // ctx.fillStyle = "#1c1c1c";
    // ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
    ctx.clearRect(0, 0, app.width, app.height);

    // 判定ライン＆水面の描画
    ctx.globalAlpha = 1; //opacity
    // bgctx.drawImage(images.girl, SCREEN_WIDTH*0.75, 85);
    // ctx.fillStyle = WATER_COLOR;
    // ctx.fillRect(0, JUDGE_LINE_Y, SCREEN_WIDTH, SCREEN_HEIGHT-JUDGE_LINE_Y);
    // drawGradRect(ctx, 0, JUDGE_LINE_Y,  SCREEN_WIDTH, SCREEN_HEIGHT-JUDGE_LINE_Y, [ [0, WATER_COLOR], [1, "rgba(255, 255, 255, 0)"] ]);
    // ctx.strokeStyle = JUDGE_LINE_COLOR;
    // ctx.beginPath(); // ライン引く
    // ctx.moveTo(0, JUDGE_LINE_Y);
    // ctx.lineTo(SCREEN_WIDTH, JUDGE_LINE_Y);
    // ctx.closePath(); // いらない？
    // ctx.stroke(); // ライン引く
    // ctx.drawImage(images.streetLight,0,0,177,474, 60, 100, 132, 358);

    // filter
    ctx.fillStyle = "rgba(87, 98, 121, 0.5)";
    ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);

    //ノーツの描画：
    ctx.save();
    // ctx.beginPath();
    for (i=currentNoteIndex, len=noteList.length; i<len; i++) {
        noteHeight = NOTE_HEIGHT;
        drawingPointX = NOTE_POSES[i%NOTE_POSES_LEN];
        noteTime = noteList[i];

        // ロングノートだったら
        if (noteTime.length) {
            ctx.fillStyle = LONG_NOTE_COLOR;
            // 最終位置に合わせて、ノーツ高さを変更する
            noteHeight = - (noteTime[1] - noteTime[0]) * corr; //上方向に伸ばすため、マイナス値
            noteTime = noteTime[0];
        } else {
            ctx.fillStyle = NOTE_COLOR;
        }

        // 待ち時間を加算
        noteTime += wait;

        // 描画位置を決める
        relativeTime = noteTime - timer.time();
        deltaY = relativeTime * corr;
        drawingPointY = NOTE_DEST_Y - deltaY;

        // 画面外だったら描画をスキップして次のループへ
        if (drawingPointY < -10) continue;

        // 判定ライン位置でストップ & ロングノートの場合高さを縮める
        if (relativeTime < 0){
            noteHeight -= relativeTime * corr;
            drawingPointY = NOTE_DEST_Y;
        }

        // ノーツ描く
        ctx.fillRect(drawingPointX, drawingPointY, NOTE_WIDTH, noteHeight);
        // ctx.rect(drawingPointX, drawingPointY, NOTE_WIDTH, noteHeight);

    }
    // ctx.fill();
    ctx.restore();



    // スコア表示とか
    // フォント設定
    ctx.fillStyle = "white"; // 色は白
    // ctx.font = "bold 20px ''Shadows Into Light, Verdana, sans-serif'"; // フォントのウエイト、サイズ、ファミリー
    ctx.font = "bold " +SCORE_TEXT_FONT_SIZE+ "px ''Audiowide, Verdana, sans-serif'"; // フォントのウエイト、サイズ、ファミリー
    // ctx.font = "bold 20px ''Merienda One, Verdana, sans-serif'"; // フォントのウエイト、サイズ、ファミリー
    // ctx.font = "bold 20px ''Henny Penny, Verdana, sans-serif'"; // フォントのウエイト、サイズ、ファミリー
    ctx.textAlign = 'center'; // 軸を文字列中央に持ってくる

    // effectPosX = drawingPointX;
    effectPosX = (longNote) ? NOTE_POSES[currentNoteIndex%NOTE_POSES_LEN] : NOTE_POSES[(currentNoteIndex-1)%NOTE_POSES_LEN];

    if (isPlaying){

        // "great!"とか
        if (rateText){
            ctx.save();
            ctx.fillStyle = (rateText.match(/great|cool/i) == null) ? "rgba(120, 158, 215, 0.68)" : "rgb(177, 224, 125)"; // 色
            // ctx.fillText(rateText, RATING_TEXT_POS_X,  RATING_TEXT_POS_Y);
            ctx.fillText(rateText, effectPosX+NOTE_WIDTH/2,  JUDGE_LINE_Y-54);
            // rateText = null;
            if (!isPlaying)  rateText = null;
            ctx.restore();
        }

        // チェイン数
        if (chainNum !== 0){
            ctx.fillText(chainNum+" CHAIN", RATING_TEXT_POS_X,  RATING_TEXT_POS_Y + 16);
        }

        //スコア
        ctx.textAlign = 'right'; //軸を文字列中央に持ってくる
        ctx.fillText(score, SCORE_TEXT_POS_X,  SCORE_TEXT_POS_Y);

        //エフェクト描画
        // effect変数には整数が入り、０以上のときに描画
        if (hitEffect > 0) {
            ctx.save();
            ctx.globalAlpha = hitEffect * 0.1; //opacity
            // drawGradRect(ctx, effectPosX, JUDGE_LINE_Y-EFFECT_HEIGHT,  NOTE_WIDTH, EFFECT_HEIGHT*1.5, [[0,"rgba(0, 0, 0, 0)"],[0.7,EFFECT_COLOR],[1,"rgba(0, 0, 0, 0)"]]);
            drawGradRect(ctx, effectPosX, JUDGE_LINE_Y-EFFECT_HEIGHT,  NOTE_WIDTH, EFFECT_HEIGHT, [[0,"rgba(0, 0, 0, 0)"],[1,EFFECT_COLOR]]);
            hitEffect--;
            ctx.restore();
        }

        //progress gauge
        ctx.save();
        var remainRatio = timer.time() / endhour;
        var PROGRESS_BAR_WIDTH = SCREEN_WIDTH * 0.3 |0;
        ctx.fillStyle = "#d5e9f1"; // 枠色
        ctx.fillRect(10,10, PROGRESS_BAR_WIDTH, 10);
        ctx.fillStyle = "#5099b6"; // ゲージ色
        ctx.fillRect(11,11, PROGRESS_BAR_WIDTH * remainRatio - 2, 9);
        ctx.restore();
    }


    // 暗幕
    if(!isPlaying){
        ctx.save();
        ctx.fillStyle = "rgba(0, 0, 0, 0.7)"; // 色
        ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);

        //
        ctx.textAlign = 'center';
        ctx.fillStyle = "rgba(255, 255, 255, 0.99)"; // 色
        ctx.globalAlpha = 0.4; //opacity
        ctx.fillText("TAP the KEY or SCREEN to START", RATING_TEXT_POS_X,  SCORE_TEXT_FONT_SIZE*2);
        ctx.globalAlpha = 1; //opacity
        if (score) {ctx.fillText("RESULT", RATING_TEXT_POS_X,  RATING_TEXT_POS_Y);}
        if (score) {ctx.fillText("SCORE: "+score+"", RATING_TEXT_POS_X,  RATING_TEXT_POS_Y+SCORE_TEXT_FONT_SIZE*1.5);}
        if (chainNum) {ctx.fillText("CHAIN: "+chainNum+" / "+maxChain, RATING_TEXT_POS_X,  RATING_TEXT_POS_Y+SCORE_TEXT_FONT_SIZE*3);}
        if (score) {ctx.fillText("結構歌えた！", RATING_TEXT_POS_X,  RATING_TEXT_POS_Y+SCORE_TEXT_FONT_SIZE*5);}
        ctx.restore();

    }

}

// draw vertical linear gradient rect
function drawGradRect(context, x, y, width, height, color){
    // var _color =  'hsla('+ colorHue +', 50%, 50%, 0.7)';
    // var _color =  color;
    context.save();

    // グラデーション領域をセット
    var grad  = context.createLinearGradient(x, y, x, y+height);

    // グラデーション終点のオフセットと色をセット
    if (color.length > 0){
        for (var i = 0, len=color.length; i < len; i++) {
            grad.addColorStop(color[i][0], color[i][1]);
        }
    } else {
        grad.addColorStop(0, 'rgba(0, 0, 0, 0)');  // 透明
        grad.addColorStop(1, color);
    }

    // グラデーションをfillStyleプロパティにセット
    // context.globalAlpha = (alpha) ? alpha : 1;
    context.fillStyle = grad;

    // 矩形を描画
    context.fillRect(x, y, width, height);

    context.restore();
}

//　判定処理
function judge() {
    var noteTime = noteList[currentNoteIndex]; // いまのノーツを見る
    var _longEnd = null; //ロング最終位置を一時保持

    //ロングノートだったら
    if (typeof noteTime == 'object') {
        _longEnd = noteTime[1];
        noteTime = noteTime[0]; // ノーツを
        _longEnd += wait;
        // console.log(noteTime);
    }
    noteTime += wait;

    // 正判定位置からどれくらいずれているか
    // var rTime = noteTime - music.currentTime + calib; // 再生位置と先頭ノーツ出現時間との差
    var rTime = noteTime - timer.time() + calib; // 再生位置と先頭ノーツ出現時間との差
    // console.log(longNote);
    // 早押し・遅押しを区別しない場合
    if (rTime < 0) rTime *= -1;

    // 判定範囲外なら何もせず終了
    if (rTime > RATING.out) return;

    longNote = _longEnd;

    if (rTime < RATING.great) return effect("great");

    if (rTime < RATING.cool) return effect("cool");

    if (rTime < RATING.good) return effect("good");

    longNote = null;

    if (rTime < RATING.out) return effect("miss");

    // 判定受付範囲外の場合は無し
    // 下のように書いても同じ

    // if (){
    // } else if (rTime) {
    //
    // }

}

// 判定時の反応 reactionでもいいかも
function effect(rating){
    if (longNote == null) currentNoteIndex++; //ロングでなければ現在ノート消す

    switch (rating) {
        case "great":
            chainNum++;
            rateText = "GREAT!!!";
            playShot(se1);
            // se1.play();
            hitEffect = 16;
            score += SCORE.great;
            // console.log("great!!!");

            break;

        case "cool":
            chainNum++;
            rateText = "COOL!";
            hitEffect = 10;
            playShot(se1);
            score += SCORE.cool;
            // console.log("cool!");
            // noteList.shift();
            break;

        case "good":
            chainNum++;
            rateText = "GOOD";
            playShot(se2);
            score += SCORE.good;
            // console.log("good");
            // noteList.shift();
            break;

        case "hold":
            // rateText = "HOLD!";
            // chainNum++;
            // playShot(se2);
            // score += SCORE.hold;
            break;

        case "miss":
            miss();
            // playShot(se2);
            // noteList.shift();
            break;

        default:
            break;
    }
}

// 使いまわせるように切り出す
function miss(){
    chainNum = 0; // チェイン切る
    rateText = "MISS...";
    // console.log("miss...");
}

// ショット音再生
function playShot(audio){
    if(!audio.ended){
        //巻き戻し再生
        audio.pause();
        audio.currentTime = 0;  // 再生位置を0秒にする
        audio.play();
    }else{
        audio.play();
    }
}

// 入力系
// mousedownとkeydown(スペースバー)で
if (!autoPlay) {
    app.addEventListener('mousedown',  function(e){ e.preventDefault();onpointdown();}, false);
    app.addEventListener('touchstart', function(e){ e.preventDefault();onpointdown();}, false);
    document.addEventListener('keydown', function(e){
        // if (e.keyCode == 32) return judge();
        // console.log(e);
        onpointdown();
    });

    // keyup系
    app.addEventListener('mouseup', onpointup, false);
    app.addEventListener('touchend', onpointup, false);
    document.addEventListener('keyup', onpointup, false);
}

function onpointdown(){
    if (!isPlaying) {
        gameReset();
        isPlaying = true;
        return;
    }
    if (isPlaying){
        if(btnFlg) return;
        btnFlg = true;
        // if(longNote) return;
        judge();
    }else{
        isPlaying = true;
    }
}
function onpointup(){
    btnFlg = false;
}

function importData(data){
    var dataobj;
    try {
        dataobj = JSON.parse(data); //オブジェクト化
    } catch(e) {
        alert(e+'\n正しいjsonデータでは無いっぽいです…');
    }
    // 各数値代入
    bpm = dataobj.BPM;
    NOTE_LIST =  dataobj.noteList;
    zerohour = dataobj.zerohour;
    if(dataobj.endhour) endhour = dataobj.endhour;
}

//==============================
$id('resetBtn').addEventListener('click', gameReset, false);

// var lastUsedHeap = 0;  // remember the heap size
//
// function checkMemory()
// {
//     // check if the heap size is this cycle is LESS than what we had last
//     // cycle; if so, then the garbage collector has kicked in
//
//     if (window.performance.memory.usedJSHeapSize < lastUsedHeap)
//         console.log('Garbage collected!');
//     lastUsedHeap = window.performance.memory.usedJSHeapSize;
// }
//
// setTimeout(checkMemory, 100); // test 10 times per second

// function audioLoader(key){
//     var audio = new Audio(SOUND_ASSETS[key]);
//     audio.addEventListener('canplaythrough', function(){
//         sounds[key] = audio;
//         console.log(Object.keys(sounds).length+" "+Object.keys(SOUND_ASSETS).length);
//         // sounds.push(audio);
//         audio.removeEventListener('canplaythrough', audioLoader);
//         if (Object.keys(sounds).length == Object.keys(SOUND_ASSETS).length) {
//             console.log(sounds[key]);
//             //loadEnd
//             init();
//         }
//     });
//     audio.onerror = function(e){
//         console.warn(e);
//     }
// }

        </script>
    </body>
</html>
