<!DOCTYPE html>
<html lang="ja">
    <head>
            <meta charset="utf-8">
            <meta http-equiv="x-ua-compatible" content="IE=Edge">
            <meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no">
            <title>リズミックレイン</title>
            <!-- <link href='https://fonts.googleapis.com/css?family=Shadows+Into+Light|Audiowide|Merienda+One|Henny+Penny' rel='stylesheet' type='text/css'> -->
            <!-- <link href='https://fonts.googleapis.com/css?family=Audiowide|Merienda+One' rel='stylesheet' type='text/css'> -->

            <style media="screen">
                body{
                    -webkit-text-size-adjust: 100%;
                    font-family: Merienda One, cursive, monospace, sans-serif;
                    /*background: rgb(12, 154, 133);*/
                    background: url("./assets/images/background.jpg") center center no-repeat fixed;
                    background-size: cover;
                    background-color: black;
                    color: rgb(208, 218, 213);
                }
                .title{
                    text-align: center;
                }
                #game-field{
                    position: relative;
                    margin: 8px auto;
                }
                canvas{
                    position: absolute;
                }
                #bg{
                    z-index: 1;
                }
                #app{
                    z-index:2;
                }
                #repertory-wrapper{
                    display: block;
                    min-height: 300px;
                    overflow: auto;
                }
                #repertory{
                    /*position: absolute;
                    top: 40%;
                    display: block;*/
                    z-index:3;
                }
                #repertory li{
                    font-size: 0.8rem;
                    width: 100px;
                    float: left;
                    color: white;
                    z-index:3;
                    background: rgb(193, 200, 105);
                    cursor: pointer;
                    padding: 0.4em;
                    display: inline-block;
                }

            </style>
        </head>
    <body>
        <div class="container">
            <h1 class="title">RHYTHMIC RAIN</h1>

            <div id="game-field">
                <canvas id="bg"></canvas>
                <canvas id="app"></canvas>
            </div>
            <div id="repertory-wrapper">
                <ul id="repertory"></ul>
            </div>
            <div class="info">
                <div id="time"></div>
                <button id="pause">pause</button>
                <button id="resetBtn">reset</button>
                <input type="number" id="seek" value="">
                <div class="instruction">
                    オーソドックスな音ゲーです。降ってくるノーツに合わせてキーボード（どのキーでもOK）を押すか、タップします。<br>
                    長いノーツは長押しします。
                </div>

            </div>


        </div><!-- container -->

        <script src="timerClass.js" charset="utf-8"></script>
        <script src="loader.js" charset="utf-8"></script>
        <script>


// var game = function(){
// };

//shorthand
var $id = function(id) { return document.getElementById(id); }
var makeSpanArray = function(span, m, n){
    var array = [];
    for (var i = m; i < m+n; i++) {
        array.push(span * i);
    }
    return array;
}
window.AudioContext = window.AudioContext || window.webkitAudioContext;
if (AudioContext) var waContext = new AudioContext();

// webaudioサウンドを再生
var playWASound = function(context,buffer) {
  // source を作成
  var source = context.createBufferSource();
  // buffer をセット
  source.buffer = buffer;
  // context に connect
  source.connect(context.destination);
  // 再生
  source.start(0);
};

// 定数
var SCREEN_WIDTH = (window.innerWidth > 640) ? 640 : window.innerWidth*0.9;
var RATIO = SCREEN_WIDTH/640;
var SCREEN_HEIGHT = Math.round(SCREEN_WIDTH/16 * 9); // 16:9 ex> 640:360
var NOTE_LIST = null;

// 画面描画用パラメータ（定数（ゲーム中に変更することの無い変数）は慣例として大文字）
var GRID_NUM = 14;
var NOTE_WIDTH = (SCREEN_WIDTH / GRID_NUM) * 0.8; // ノーツの幅：画面サイズで変える？
var NOTE_HEIGHT = 6;

var NOTE_POS_SPAN = SCREEN_WIDTH / GRID_NUM;
// var NOTE_POSES = [NOTE_POS_SPAN*3, NOTE_POS_SPAN*4, NOTE_POS_SPAN*5, NOTE_POS_SPAN*6];
var NOTE_POSES = makeSpanArray(NOTE_POS_SPAN, 5, 4);
var NOTE_POSES_LEN = NOTE_POSES.length;

var NOTE_COLOR = "rgb(139, 236, 242)";
var LONG_NOTE_COLOR = "rgb(77, 60, 212)";
// var WATER_COLOR = "#146f9b";
var WATER_COLOR = "#125779";
var EFFECT_COLOR = NOTE_COLOR;
// var EFFECT_COLOR = "rgba(152, 171, 236, 1)";

var JUDGE_LINE_Y = Math.round(SCREEN_HEIGHT * 0.7); //
var NOTE_DEST_Y = JUDGE_LINE_Y - NOTE_HEIGHT * 0.5; // ノーツ最終位置Y
var EFFECT_HEIGHT = JUDGE_LINE_Y * 0.4; // エフェクトの高さ

var RATING_TEXT_POS_X = SCREEN_WIDTH * 0.5;
var RATING_TEXT_POS_Y = SCREEN_HEIGHT * 0.4;
var SCORE_TEXT_FONT_SIZE = 20*RATIO;
var SCORE_TEXT_POS_X =  SCREEN_WIDTH * 0.9;
var SCORE_TEXT_POS_Y = SCORE_TEXT_FONT_SIZE * 1.1;

var LIGHT_POS_X = 60*RATIO;
var LIGHT_POS_Y = 110*RATIO;
var GIRL_POS_X = SCREEN_WIDTH * 0.75;
var GIRL_POS_Y = 75 * RATIO;

// 判定範囲（sec）
var RATING = {
    out: 0.13,
    good: 0.10,
    cool: 0.05,
    great: 0.03
};
// 加点設定
var SCORE = {
    good: 10,
    cool: 50,
    great: 100,
    hold: 10
};
var activeMusicIndex = 0;
var musicList = [
    {
        name: "Game gadget at midnight",
        author: "MATSU",
        anchor: "http://dova-s.jp/_contents/author/profile089.html",
        difficulty: "normal",
        theme: "night",
        src: "./assets/Game_gadget_at_midnight.mp3",
        fumen: "./data/midnight-fumen_rev1.json"
    },{
        name: "dummy",
        author: "dummy",
        anchor: "http://dova-s.jp/_contents/author/profile089.html",
        src: "./assets/dummy.mp3",
        fumenData: "./data/midnight-fumen_rev1.json"
    },
];

// レパートリーリスト
musicList.forEach(function(music, index){
    // music['active'] = false;
    var li = document.createElement('li');
    // li.setAttribute("data-active", "false");
    li.textContent = music.name;

    li.onclick = function(){
        var childs = $id('repertory').childNodes;
        // console.log(childs);
        // musicList.forEach(function(_music){
        //     _music.active = false;
        // })
        // music.active = true;
        // console.log(musicList);

        Object.keys(childs).forEach(function(i){
            var c = childs[i];
            // console.log(c);
            // c.dataset.active = 'false';
            c.style.background = 'rgb(161, 182, 241)';
        });
        // this.dataset.active = 'true';
        activeMusicIndex = index;
        this.style.background = 'rgb(60, 100, 214)';
        console.log(activeMusicIndex);
    }
    $id('repertory').appendChild(li);
});

var SOUND_ASSETS = {
    // bgm: "./assets/two_tor_real.mp3",
    bgm: "./assets/Game_gadget_at_midnight.mp3",
    clap:"./assets/clap.mp3",
    conga: "./assets/conga.mp3"
};
var IMAGE_ASSETS = {
    streetLight: "./assets/images/streetLight2.png",
    girl: "./assets/images/girl.png",
}

// 要素取得
var app = $id('app');
var bgCanvas = $id('bg');
var holderElement = $id('game-field');
var timerNode = $id('time');
function pause(){
    music.pause();
    timer.pause();
    isPlaying = false;
}
$id('pause').addEventListener('click', pause);

$id('seek').onblur = function(){
    timer.setTime(this.value);
    music.currentTime = this.value;
}

var timer;

// 情報格納用変数
var noteList = []; //譜面情報
var hitEffect = null;
var score = 0;
var chainNum = 0;
var maxChain = 0; //マックス
var fullChainNum = 1; // フルコンボ時の数値
var rateText = null;
var longNote = null; // ロングノート情報
var btnFlg = false; // ボタンが押下状態フラグ

var isPlaying = false; // プレイ中
var autoPlay = false;
// var autoPlay = true;
var enableSE = false;

var bpm = 120; // dummy
var speed = 1.0;

var currentNoteIndex = 0;

// 譜面位置・判定調整用
var calib = 0; // 判定調整用　RATING.good判定より小さいこと
var zerohour = 0; // （音源中での実際の音楽再生開始時間）譜面load時に修正される
var endhour = 0; // ゲーム終了時間：音源ロード時に設定
var wait = 3.0; // 音源再生までの待ち時間
// var wait = zerohour + _wait; //  計算に利用する最終的な待ち時間

// sound preload
var sounds = {} // サウンド管理;
var images = {} // image管理;
var music, se1, se2;

// 0. スタート
window.onload = function(){
    // 1. 画像ロード
    _imagePreload(IMAGE_ASSETS, images, function(){
        // 2. 初期化（canvasセット, 譜面ロード, タイマー）
        init();
        main();
        // 2.5 music select ?
        // 3. 初回タップ、クリックでスタート
        var _func = (function(e) {
            return function f(e) {
                _soundPreload(SOUND_ASSETS, sounds, function(){
                    music = sounds.bgm;
                    se1 =  sounds.clap;
                    se2 =  sounds.conga;
                    // 入力系
                    if (!autoPlay) {
                        app.addEventListener('mousedown',  function(e){ e.preventDefault();onpointdown();}, false);
                        app.addEventListener('touchstart', function(e){ e.preventDefault();onpointdown();}, false);
                        document.addEventListener('keydown', function(e){
                            // if (e.keyCode == 32) return judge();
                            onpointdown();
                        });

                        // keyup系
                        app.addEventListener('mouseup', onpointup, false);
                        app.addEventListener('touchend', onpointup, false);
                        document.addEventListener('keyup', onpointup, false);
                    }

                    isPlaying = true;
                    gameReset();
                });

                // イベントリスナ消す
                app.removeEventListener(e.type, _func, false);
            }
        })();
        app.addEventListener('click', _func, false);
        app.addEventListener('touchstart', _func, false)
    });

};

function init() {
    timer = new Timer();

    // set up main canvas
    app.width = bgCanvas.width = SCREEN_WIDTH;
    app.height = bgCanvas.height  = SCREEN_HEIGHT;
    holderElement.style.width = SCREEN_WIDTH +"px";
    holderElement.style.height = SCREEN_HEIGHT +"px";
    // draw once: background
    var bgctx = bgCanvas.getContext('2d');
    bgctx.fillStyle = "rgb(249, 250, 207)";
    bgctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT); //bgcolor
    bgctx.drawImage(images.girl, GIRL_POS_X, GIRL_POS_Y, 124*1.1*RATIO, 166*1.1*RATIO);
    drawGradRect(bgctx, 0, JUDGE_LINE_Y,  SCREEN_WIDTH, SCREEN_HEIGHT-JUDGE_LINE_Y, [ [0, WATER_COLOR], [1, "rgba(255, 255, 255, 0)"] ]);
    // bgctx.drawImage(images.streetLight,0,0,177,474, 60, 100, 132, 358);
    bgctx.drawImage(images.streetLight,0,0,118,308, LIGHT_POS_X, LIGHT_POS_Y, 132*RATIO, 358*RATIO);
    bgctx.fillStyle = "rgba(34, 34, 34, 0.7)";
    bgctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT); //filter

    // ajaxで譜面情報の取得
    var httpObj = new XMLHttpRequest();
    // httpObj.open("get", "./data/midnight-fumen_sorted.json", true);
    httpObj.open("get", "./data/midnight-fumen_rev1.json", true);
    httpObj.onload = function(){
        importData(this.responseText);

        // フルコンボ数
        noteList = NOTE_LIST.slice();
        noteList.forEach(function(note){
            if(note.length){
                fullChainNum += 2;
            } else {
                fullChainNum++;
            }
        });
        if (endhour == 0) endhour = music.duration + wait;

        // gameReset();

        if (autoPlay) btnFlg = true;

    }
    httpObj.onerror = function(e){
        console.log(e);
        alert('xmlエラー');
    }
    httpObj.send(null);

}

function gameReset(){
    currentNoteIndex = 0;
    // music.pause();
    music.currentTime = zerohour; //0以下の場合は0になる？
    rateText = null;
    chainNum = 0;
    maxChain = 0;
    score = 0;
    hitEffect = 0;
    timer.reset();
    timer.run();
    // isPlaying = true;
    // console.log(noteList);
    console.log("reset");
}

// main loop
function main() {
    if (isPlaying){
        timer.update();
        timerNode.innerHTML = timer.time();
        calc();
    };
    screenRender();

    setTimeout(main, 1000/60);
}

// 内部処理
function calc(){
    var i, len;
    var noteTime;

    // if (!isPlaying) return;
    var time = timer.time();

    // 時間が来たら音楽再生開始
    if (time > wait && music.paused) {
        console.log("music start");
        // music.play();
        playSound(music);
    }
    // endhour に達したら
    if (time > endhour && !music.paused) {
        console.log("music end");
        music.volume -= 0.1;
        music.pause();
    }
    if (time > endhour){
        isPlaying = false;
    }

    for (i = currentNoteIndex, len=noteList.length; i < len; i++){
        noteTime = noteList[i];
    // noteList.forEach(function(noteTime){

        // ロングノートだったら
        if (typeof noteTime == 'object') {
            noteTime = noteTime[0];
        }

        // 無入力判定：判定ラインを超え、かつ判定時間を過ぎたらmiss判定、そして次のターゲットへ
        // ロングノート判定中は引っかからないようにする
        if (time > noteTime+wait + RATING.good && !longNote){
            miss();
            // noteList.shift();
            currentNoteIndex++;
        }

        //オートプレイ
        //great範囲内に入ったら即座に反応
        // ロングノート判定中にロングノート情報を消さないようにする
        if (autoPlay && !longNote) {
            if (time > noteTime + wait - RATING.great){
                judge();
                // noteList.shift();
                // currentNoteIndex++;

            }
        }
    }

    // long note 処理
    if (longNote != null) {
        var rTime = longNote - time + calib;

        // ボタンを押している
        if (btnFlg) {
            // 終了時間に達していない
            if (rTime > 0) {
                // console.log('ji');
                hitEffect = 3;
                // effect('hold');
            // 規定時間まで押しつづけたら終了
            }else{
                longNote = null;
                effect('great');
            }

        // 途中で離してしまった
        }else{
            longNote = null;
            effect('miss');
        }
    }

}

function screenRender() {
    var ctx = app.getContext('2d');
    var relativeTime = 0; // 再生位置とノーツ出現情報との差、０のとき判定ライン位置になるように
    var corr = bpm * 1.75 * RATIO * speed; // 補正、ハイスピ
    var deltaY; // 判定ラインまでの距離
    var drawingPointX = 100; // X軸 描画位置
    var drawingPointY; // Y軸 描画位置
    var noteHeight = 0;
    var effectPosX = null; // エフェクトX位置
    var i, len;
    var noteTime = null;

    //画面初期化：背景色で塗りつぶす
    // ctx.fillStyle = "rgba(0, 0, 0, 0.5)"; // ブラーエフェクト
    // ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
    ctx.clearRect(0, 0, app.width, app.height);

    // filter
    ctx.fillStyle = "rgba(87, 98, 121, 0.5)";
    ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);

    //ノーツの描画：
    ctx.save();
    // ctx.beginPath();
    for (i=currentNoteIndex, len=noteList.length; i<len; i++) {
        noteHeight = NOTE_HEIGHT;
        drawingPointX = NOTE_POSES[i%NOTE_POSES_LEN];
        noteTime = noteList[i];

        // ロングノートだったら
        if (noteTime.length) {
            ctx.fillStyle = LONG_NOTE_COLOR;
            // 最終位置に合わせて、ノーツ高さを変更する
            noteHeight = - (noteTime[1] - noteTime[0]) * corr; //上方向に伸ばすため、マイナス値
            noteTime = noteTime[0];
        } else {
            ctx.fillStyle = NOTE_COLOR;
        }

        // 待ち時間を加算
        noteTime += wait;

        // 描画位置を決める
        relativeTime = noteTime - timer.time();
        deltaY = relativeTime * corr;
        drawingPointY = NOTE_DEST_Y - deltaY;

        // 画面外だったら描画をスキップして次のループへ
        if (drawingPointY < -10) continue;

        // 判定ライン位置でストップ & ロングノートの場合高さを縮める
        if (relativeTime < 0){
            noteHeight -= relativeTime * corr;
            drawingPointY = NOTE_DEST_Y;
        }

        // ノーツ描く
        ctx.fillRect(drawingPointX, drawingPointY, NOTE_WIDTH, noteHeight);
        // ctx.rect(drawingPointX, drawingPointY, NOTE_WIDTH, noteHeight);

    }
    // ctx.fill();
    ctx.restore();

    // スコア表示とか
    // フォント設定
    ctx.fillStyle = "white"; // 色は白
    // ctx.font = "bold 20px ''Shadows Into Light, Verdana, sans-serif'"; // フォントのウエイト、サイズ、ファミリー
    ctx.font = "bold " +SCORE_TEXT_FONT_SIZE+ "px ''Audiowide, Verdana, sans-serif'"; // フォントのウエイト、サイズ、ファミリー
    // ctx.font = "bold 20px ''Merienda One, Verdana, sans-serif'"; // フォントのウエイト、サイズ、ファミリー
    // ctx.font = "bold 20px ''Henny Penny, Verdana, sans-serif'"; // フォントのウエイト、サイズ、ファミリー
    ctx.textAlign = 'center'; // 軸を文字列中央に持ってくる

    // effectPosX = drawingPointX;
    effectPosX = (longNote) ? NOTE_POSES[currentNoteIndex%NOTE_POSES_LEN] : NOTE_POSES[(currentNoteIndex-1)%NOTE_POSES_LEN];

    if (isPlaying){

        // "great!"とか
        if (rateText){
            ctx.save();
            ctx.fillStyle = (rateText.match(/great|cool/i) == null) ? "rgba(120, 158, 215, 0.68)" : "rgb(177, 224, 125)"; // 色
            // ctx.fillText(rateText, RATING_TEXT_POS_X,  RATING_TEXT_POS_Y);
            ctx.fillText(rateText, effectPosX+NOTE_WIDTH/2,  JUDGE_LINE_Y-54);
            // rateText = null;
            if (!isPlaying)  rateText = null;
            ctx.restore();
        }

        // チェイン数
        if (chainNum !== 0){
            ctx.fillText(chainNum+" CHAIN", RATING_TEXT_POS_X,  RATING_TEXT_POS_Y + 16);
        }

        //スコア
        ctx.textAlign = 'right'; //軸を文字列中央に持ってくる
        ctx.fillText(score, SCORE_TEXT_POS_X,  SCORE_TEXT_POS_Y);

        //エフェクト描画
        // effect変数には整数が入り、０以上のときに描画
        if (hitEffect > 0) {
            ctx.save();
            ctx.globalAlpha = hitEffect * 0.1; //opacity
            // drawGradRect(ctx, effectPosX, JUDGE_LINE_Y-EFFECT_HEIGHT,  NOTE_WIDTH, EFFECT_HEIGHT*1.5, [[0,"rgba(0, 0, 0, 0)"],[0.7,EFFECT_COLOR],[1,"rgba(0, 0, 0, 0)"]]);
            drawGradRect(ctx, effectPosX, JUDGE_LINE_Y-EFFECT_HEIGHT,  NOTE_WIDTH, EFFECT_HEIGHT, [[0,"rgba(0, 0, 0, 0)"],[1,EFFECT_COLOR]]);
            hitEffect--;
            ctx.restore();
        }

        //progress gauge
        ctx.save();
        var remainRatio = timer.time() / endhour;
        var PROGRESS_BAR_WIDTH = SCREEN_WIDTH * 0.3 |0;
        ctx.fillStyle = "#d5e9f1"; // 枠色
        ctx.fillRect(10,10, PROGRESS_BAR_WIDTH, 10);
        ctx.fillStyle = "#5099b6"; // ゲージ色
        ctx.fillRect(11,11, PROGRESS_BAR_WIDTH * remainRatio - 2, 9);
        ctx.restore();

        // レパートリーリスト消す
        $id('repertory').style.visibility = "hidden";
    }


    // 暗幕
    if(!isPlaying){
        ctx.save();
        ctx.fillStyle = "rgba(0, 0, 0, 0.7)"; // 色
        ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);

        //
        ctx.textAlign = 'center';
        ctx.fillStyle = "rgba(255, 255, 255, 0.99)"; // 色
        ctx.globalAlpha = 0.4; //opacity
        ctx.fillText("TAP the KEY or SCREEN to START", RATING_TEXT_POS_X,  SCORE_TEXT_FONT_SIZE*2);
        ctx.globalAlpha = 1; //opacity
        if (score) {ctx.fillText("RESULT", RATING_TEXT_POS_X,  RATING_TEXT_POS_Y);}
        if (score) {ctx.fillText("SCORE: "+score+"", RATING_TEXT_POS_X,  RATING_TEXT_POS_Y+SCORE_TEXT_FONT_SIZE*1.5);}
        if (maxChain) {ctx.fillText("CHAIN: "+maxChain+" / "+fullChainNum, RATING_TEXT_POS_X,  RATING_TEXT_POS_Y+SCORE_TEXT_FONT_SIZE*3);}
        // if (score) {ctx.fillText("結構歌えた！", RATING_TEXT_POS_X,  RATING_TEXT_POS_Y+SCORE_TEXT_FONT_SIZE*5);}
        ctx.restore();

        $id('repertory').style.visibility = "visible";
    }

}

// draw vertical linear gradient rect
function drawGradRect(context, x, y, width, height, color){
    context.save();

    // グラデーション領域をセット
    // console.log(width, height);
    var grad  = context.createLinearGradient(x, y, x, y+height);

    // グラデーション終点のオフセットと色をセット
    if (color.length > 0){
        for (var i = 0, len=color.length; i < len; i++) {
            grad.addColorStop(color[i][0], color[i][1]);
        }
    } else {
        grad.addColorStop(0, 'rgba(0, 0, 0, 0)');  // 透明
        grad.addColorStop(1, color);
    }

    // グラデーションをfillStyleプロパティにセット
    // context.globalAlpha = (alpha) ? alpha : 1;
    context.fillStyle = grad;

    // 矩形を描画
    context.fillRect(x, y, width, height);

    context.restore();
}

//　判定処理
function judge() {
    var noteTime = noteList[currentNoteIndex]; // いまのノーツを見る
    var _longEnd = null; //ロング最終位置を一時保持

    //ロングノートだったら
    if (typeof noteTime == 'object') {
        _longEnd = noteTime[1];
        noteTime = noteTime[0]; // ノーツを
        _longEnd += wait;
        // console.log(noteTime);
    }
    noteTime += wait;

    // 正判定位置からどれくらいずれているか
    // var rTime = noteTime - music.currentTime + calib; // 再生位置と先頭ノーツ出現時間との差
    var rTime = noteTime - timer.time() + calib; // 再生位置と先頭ノーツ出現時間との差
    // console.log(longNote);
    // 早押し・遅押しを区別しない場合
    if (rTime < 0) rTime *= -1;

    // 判定範囲外なら何もせず終了
    if (rTime > RATING.out) return;

    longNote = _longEnd;

    if (rTime < RATING.great) return effect("great");

    if (rTime < RATING.cool) return effect("cool");

    if (rTime < RATING.good) return effect("good");

    longNote = null;

    if (rTime < RATING.out) return effect("miss");

    // 判定受付範囲外の場合は無し
    // 下のように書いても同じ

    // if (){
    // } else if (rTime) {
    //
    // }

}

// 判定時の反応 reactionでもいいかも
function effect(rating){
    if (longNote == null) currentNoteIndex++; //ロングでなければ現在ノート消す

    switch (rating) {
        case "great":
            chainNum++;
            rateText = "GREAT!!!";
            playShot(se1);
            // se1.play();
            hitEffect = 16;
            score += SCORE.great;
            // console.log("great!!!");

            break;

        case "cool":
            chainNum++;
            rateText = "COOL!";
            hitEffect = 10;
            playShot(se1);
            score += SCORE.cool;
            // console.log("cool!");
            // noteList.shift();
            break;

        case "good":
            chainNum++;
            rateText = "GOOD";
            playShot(se2);
            score += SCORE.good;
            // console.log("good");
            // noteList.shift();
            break;

        case "hold":
            // rateText = "HOLD!";
            // chainNum++;
            // playShot(se2);
            // score += SCORE.hold;
            break;

        case "miss":
            miss();
            // playShot(se2);
            // noteList.shift();
            break;

        default:
            break;
    }
}

// 使いまわせるように切り出す
function miss(){
    // ゼロもしくは更新時に
    if (maxChain == 0 || maxChain < chainNum) {
        maxChain = chainNum;
    }
    chainNum = 0; // チェイン切る
    rateText = "MISS...";
    // console.log("miss...");
}

// ショット音再生
function playShot(audio){
    if(!enableSE) return;
    if(!audio.ended){
        //巻き戻し再生
        audio.pause();
        audio.currentTime = 0;  // 再生位置を0秒にする
        audio.play();
    }else{
        audio.play();
    }
}

function playSound(audio){
    if (waContext) {
        playWASound(audio);
    } else {
        audio.play();
    }
}
function pauseSound(audio){

}

function onpointdown(){
    if (!isPlaying) {
        gameReset();
        isPlaying = true;
        return;
    }
    if (isPlaying){
        if(btnFlg) return;
        btnFlg = true;
        // if(longNote) return;
        judge();
    }else{
        isPlaying = true;
    }
}
function onpointup(e){
    e.preventDefault();
    btnFlg = false;
}

function importData(data){
    var dataobj;
    try {
        dataobj = JSON.parse(data); //オブジェクト化
    } catch(e) {
        alert(e+'\n正しいjsonデータでは無いっぽいです…');
    }
    // 各数値代入
    bpm = dataobj.BPM;
    NOTE_LIST =  dataobj.noteList;
    zerohour = dataobj.zerohour;
    if(dataobj.endhour) endhour = dataobj.endhour + wait;
}

//==============================
$id('resetBtn').addEventListener('click', gameReset, false);

// var lastUsedHeap = 0;  // remember the heap size
//
// function checkMemory()
// {
//     // check if the heap size is this cycle is LESS than what we had last
//     // cycle; if so, then the garbage collector has kicked in
//
//     if (window.performance.memory.usedJSHeapSize < lastUsedHeap)
//         console.log('Garbage collected!');
//     lastUsedHeap = window.performance.memory.usedJSHeapSize;
// }
//
// setTimeout(checkMemory, 100); // test 10 times per second

// function audioLoader(key){
//     var audio = new Audio(SOUND_ASSETS[key]);
//     audio.addEventListener('canplaythrough', function(){
//         sounds[key] = audio;
//         console.log(Object.keys(sounds).length+" "+Object.keys(SOUND_ASSETS).length);
//         // sounds.push(audio);
//         audio.removeEventListener('canplaythrough', audioLoader);
//         if (Object.keys(sounds).length == Object.keys(SOUND_ASSETS).length) {
//             console.log(sounds[key]);
//             //loadEnd
//             init();
//         }
//     });
//     audio.onerror = function(e){
//         console.warn(e);
//     }
// }

        </script>
    </body>
</html>
